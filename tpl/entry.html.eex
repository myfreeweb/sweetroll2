<%= if length(as_many(@entry.props["in-reply-to"])) do %>
	<%= icon name: "reply", class: ["entry-type-icon", "entry-type-icon-reply"], title: "In reply to" %>
<% end %>

<%= for irt <- Stream.map(as_many(@entry.props["in-reply-to"]), fn e -> to_cite(e, preload: @preload) end) do %>
	<div class="entry-ctx entry-txt">
		<%= cite cite: irt, class: "u-in-reply-to" %>
	</div>
<% end %>

<%= if @entry.props["name"] do %>
	<h1 class="p-name entry-txt">
		<%= content_tag :a, [href: @entry.url, class: "u-url"], do: @entry.props["name"] %>
	</h1>
<% end %>

<% content_tree = Floki.parse safe_to_string content_rendered @entry.props["content"] %>

<%= for photo <- exclude_inlined_media(content_tree, "photo", as_many(@entry.props["photo"])) do %>
	<%= photo_rendered photo %>
<% end %>

<%= if content_tree != [] do %>
	<div class="e-content entry-txt">
		<%= {:safe, inline_media_into_content(content_tree, photo: as_many(@entry.props["photo"]), video: as_many(@entry.props["video"]), audio: as_many(@entry.props["audio"])) } %>
	</div>
<% end %>

<div class="entry-info entry-txt">
	posted
	<%= time_permalink @entry, rel: "bookmark" %>

	in
	<%= for feed <- Stream.filter(Doc.feeds(@preload), fn f -> Doc.in_feed?(@entry, f) end) do %>
		<%= content_tag :a, href: feed.url, rel: "feed", type: "text/html", class: (if feed.url == @cur_url, do: "current", else: "") do %>
			<%= as_one feed.props["name"] %>
		<% end %>
	<% end %>

	<%= if @entry.props["client-id"] do %>
		using
		<%= client_id @entry.props["client-id"] %>
	<% end %>

	<%= if @entry.updated do %>
		and updated
		<%= content_tag :time, datetime: DateTime.to_iso8601(@entry.updated), class: "dt-updated" do %>
			<%= DateTime.to_iso8601 @entry.updated %>
		<% end %>
	<% end %>

	<%= if @entry.props["syndication"] do %>
		/ also on:
		<%= for synd <- as_many(@entry.props["syndication"]) do %>
			<%= content_tag :a, href: synd, class: "u-syndication" do %>
				<%= syndication_name synd %>
			<% end %>
		<% end %>
	<% end %>
</div>
